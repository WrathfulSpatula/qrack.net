const Qrack = (() => {
  const _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined

  return (
    function (moduleArg = {}) {
      const Module = moduleArg; let readyPromiseResolve, readyPromiseReject; Module.ready = new Promise((resolve, reject) => { readyPromiseResolve = resolve; readyPromiseReject = reject }); let moduleOverrides = Object.assign({}, Module); let arguments_ = []; let thisProgram = './this.program'; let quit_ = (status, toThrow) => { throw toThrow }; const ENVIRONMENT_IS_WEB = false; const ENVIRONMENT_IS_WORKER = true; let scriptDirectory = ''; function locateFile (path) { if (Module.locateFile) { return Module.locateFile(path, scriptDirectory) } return scriptDirectory + path } let read_, readAsync, readBinary; if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = self.location.href } else if (typeof document !== 'undefined' && document.currentScript) { scriptDirectory = document.currentScript.src } if (_scriptDir) { scriptDirectory = _scriptDir } if (scriptDirectory.indexOf('blob:') !== 0) { scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1) } else { scriptDirectory = '' } { read_ = url => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.send(null); return xhr.responseText }; if (ENVIRONMENT_IS_WORKER) { readBinary = url => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.responseType = 'arraybuffer'; xhr.send(null); return new Uint8Array(xhr.response) } }readAsync = (url, onload, onerror) => { const xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = () => { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return }onerror() }; xhr.onerror = onerror; xhr.send(null) } } } else {} const out = Module.print || console.log.bind(console); const err = Module.printErr || console.error.bind(console); Object.assign(Module, moduleOverrides); moduleOverrides = null; if (Module.arguments)arguments_ = Module.arguments; if (Module.thisProgram)thisProgram = Module.thisProgram; if (Module.quit)quit_ = Module.quit; let wasmBinary; if (Module.wasmBinary)wasmBinary = Module.wasmBinary; if (typeof WebAssembly !== 'object') { abort('no native wasm support detected') } let wasmMemory; let ABORT = false; let EXITSTATUS; let HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; function updateMemoryViews () { const b = wasmMemory.buffer; Module.HEAP8 = HEAP8 = new Int8Array(b); Module.HEAP16 = HEAP16 = new Int16Array(b); Module.HEAPU8 = HEAPU8 = new Uint8Array(b); Module.HEAPU16 = HEAPU16 = new Uint16Array(b); Module.HEAP32 = HEAP32 = new Int32Array(b); Module.HEAPU32 = HEAPU32 = new Uint32Array(b); Module.HEAPF32 = HEAPF32 = new Float32Array(b); Module.HEAPF64 = HEAPF64 = new Float64Array(b) } const __ATPRERUN__ = []; const __ATINIT__ = []; const __ATPOSTRUN__ = []; let runtimeInitialized = false; function preRun () { if (Module.preRun) { if (typeof Module.preRun === 'function')Module.preRun = [Module.preRun]; while (Module.preRun.length) { addOnPreRun(Module.preRun.shift()) } }callRuntimeCallbacks(__ATPRERUN__) } function initRuntime () { runtimeInitialized = true; callRuntimeCallbacks(__ATINIT__) } function postRun () { if (Module.postRun) { if (typeof Module.postRun === 'function')Module.postRun = [Module.postRun]; while (Module.postRun.length) { addOnPostRun(Module.postRun.shift()) } }callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun (cb) { __ATPRERUN__.unshift(cb) } function addOnInit (cb) { __ATINIT__.unshift(cb) } function addOnPostRun (cb) { __ATPOSTRUN__.unshift(cb) } let runDependencies = 0; let runDependencyWatcher = null; let dependenciesFulfilled = null; function addRunDependency (id) { runDependencies++; Module.monitorRunDependencies?.(runDependencies) } function removeRunDependency (id) { runDependencies--; Module.monitorRunDependencies?.(runDependencies); if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null } if (dependenciesFulfilled) { const callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } } function abort (what) { Module.onAbort?.(what); what = 'Aborted(' + what + ')'; err(what); ABORT = true; EXITSTATUS = 1; what += '. Build with -sASSERTIONS for more info.'; const e = new WebAssembly.RuntimeError(what); readyPromiseReject(e); throw e } const dataURIPrefix = 'data:application/octet-stream;base64,'; const isDataURI = filename => filename.startsWith(dataURIPrefix); let wasmBinaryFile; wasmBinaryFile = 'Qrack.wasm'; if (!isDataURI(wasmBinaryFile)) { wasmBinaryFile = locateFile(wasmBinaryFile) } function getBinarySync (file) { if (file == wasmBinaryFile && wasmBinary) { return new Uint8Array(wasmBinary) } if (readBinary) { return readBinary(file) } throw 'both async and sync fetching of the wasm failed' } function getBinaryPromise (binaryFile) { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) { if (typeof fetch === 'function') { return fetch(binaryFile, { credentials: 'same-origin' }).then(response => { if (!response.ok) { throw "failed to load wasm binary file at '" + binaryFile + "'" } return response.arrayBuffer() }).catch(() => getBinarySync(binaryFile)) } } return Promise.resolve().then(() => getBinarySync(binaryFile)) } function instantiateArrayBuffer (binaryFile, imports, receiver) { return getBinaryPromise(binaryFile).then(binary => WebAssembly.instantiate(binary, imports)).then(instance => instance).then(receiver, reason => { err(`failed to asynchronously prepare wasm: ${reason}`); abort(reason) }) } function instantiateAsync (binary, binaryFile, imports, callback) { if (!binary && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(binaryFile) && typeof fetch === 'function') { return fetch(binaryFile, { credentials: 'same-origin' }).then(response => { const result = WebAssembly.instantiateStreaming(response, imports); return result.then(callback, function (reason) { err(`wasm streaming compile failed: ${reason}`); err('falling back to ArrayBuffer instantiation'); return instantiateArrayBuffer(binaryFile, imports, callback) }) }) } return instantiateArrayBuffer(binaryFile, imports, callback) } function createWasm () { const info = { a: wasmImports }; function receiveInstance (instance, module) { wasmExports = instance.exports; wasmExports = applySignatureConversions(wasmExports); wasmMemory = wasmExports.W; updateMemoryViews(); wasmTable = wasmExports.Y; addOnInit(wasmExports.X); removeRunDependency('wasm-instantiate'); return wasmExports }addRunDependency('wasm-instantiate'); function receiveInstantiationResult (result) { receiveInstance(result.instance) } if (Module.instantiateWasm) { try { return Module.instantiateWasm(info, receiveInstance) } catch (e) { err(`Module.instantiateWasm callback failed with error: ${e}`); readyPromiseReject(e) } }instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject); return {} } var callRuntimeCallbacks = callbacks => { while (callbacks.length > 0) { callbacks.shift()(Module) } }; const noExitRuntime = Module.noExitRuntime || true; const exceptionCaught = []; let uncaughtExceptionCount = 0; function ___cxa_begin_catch (ptr) { ptr >>>= 0; const info = new ExceptionInfo(ptr); if (!info.get_caught()) { info.set_caught(true); uncaughtExceptionCount-- }info.set_rethrown(false); exceptionCaught.push(info); ___cxa_increment_exception_refcount(info.excPtr); return info.get_exception_ptr() } let exceptionLast = 0; const ___cxa_end_catch = () => { _setThrew(0, 0); const info = exceptionCaught.pop(); ___cxa_decrement_exception_refcount(info.excPtr); exceptionLast = 0 }; function ExceptionInfo (excPtr) { this.excPtr = excPtr; this.ptr = excPtr - 24; this.set_type = function (type) { HEAPU32[this.ptr + 4 >>> 2 >>> 0] = type }; this.get_type = function () { return HEAPU32[this.ptr + 4 >>> 2 >>> 0] }; this.set_destructor = function (destructor) { HEAPU32[this.ptr + 8 >>> 2 >>> 0] = destructor }; this.get_destructor = function () { return HEAPU32[this.ptr + 8 >>> 2 >>> 0] }; this.set_caught = function (caught) { caught = caught ? 1 : 0; HEAP8[this.ptr + 12 >>> 0 >>> 0] = caught }; this.get_caught = function () { return HEAP8[this.ptr + 12 >>> 0 >>> 0] != 0 }; this.set_rethrown = function (rethrown) { rethrown = rethrown ? 1 : 0; HEAP8[this.ptr + 13 >>> 0 >>> 0] = rethrown }; this.get_rethrown = function () { return HEAP8[this.ptr + 13 >>> 0 >>> 0] != 0 }; this.init = function (type, destructor) { this.set_adjusted_ptr(0); this.set_type(type); this.set_destructor(destructor) }; this.set_adjusted_ptr = function (adjustedPtr) { HEAPU32[this.ptr + 16 >>> 2 >>> 0] = adjustedPtr }; this.get_adjusted_ptr = function () { return HEAPU32[this.ptr + 16 >>> 2 >>> 0] }; this.get_exception_ptr = function () { const isPointer = ___cxa_is_pointer_type(this.get_type()); if (isPointer) { return HEAPU32[this.excPtr >>> 2 >>> 0] } const adjusted = this.get_adjusted_ptr(); if (adjusted !== 0) return adjusted; return this.excPtr } } function ___resumeException (ptr) { ptr >>>= 0; if (!exceptionLast) { exceptionLast = ptr } throw exceptionLast } const findMatchingCatch = args => { const thrown = exceptionLast; if (!thrown) { setTempRet0(0); return 0 } const info = new ExceptionInfo(thrown); info.set_adjusted_ptr(thrown); const thrownType = info.get_type(); if (!thrownType) { setTempRet0(0); return thrown } for (const arg in args) { const caughtType = args[arg]; if (caughtType === 0 || caughtType === thrownType) { break } const adjusted_ptr_addr = info.ptr + 16; if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) { setTempRet0(caughtType); return thrown } }setTempRet0(thrownType); return thrown }; function ___cxa_find_matching_catch_2 () { return findMatchingCatch([]) } function ___cxa_find_matching_catch_3 (arg0) { arg0 >>>= 0; return findMatchingCatch([arg0]) } const ___cxa_rethrow = () => { const info = exceptionCaught.pop(); if (!info) { abort('no exception to throw') } const ptr = info.excPtr; if (!info.get_rethrown()) { exceptionCaught.push(info); info.set_rethrown(true); info.set_caught(false); uncaughtExceptionCount++ }exceptionLast = ptr; throw exceptionLast }; function ___cxa_throw (ptr, type, destructor) { ptr >>>= 0; type >>>= 0; destructor >>>= 0; const info = new ExceptionInfo(ptr); info.init(type, destructor); exceptionLast = ptr; uncaughtExceptionCount++; throw exceptionLast } const ___cxa_uncaught_exceptions = () => uncaughtExceptionCount; function __embind_register_bigint (primitiveType, name, size, minRange, maxRange) { primitiveType >>>= 0; name >>>= 0; size >>>= 0 } const embind_init_charCodes = () => { const codes = new Array(256); for (let i = 0; i < 256; ++i) { codes[i] = String.fromCharCode(i) }embind_charCodes = codes }; let embind_charCodes; const readLatin1String = ptr => { let ret = ''; let c = ptr; while (HEAPU8[c >>> 0]) { ret += embind_charCodes[HEAPU8[c++ >>> 0]] } return ret }; const awaitingDependencies = {}; const registeredTypes = {}; const typeDependencies = {}; let BindingError; const throwBindingError = message => { throw new BindingError(message) }; let InternalError; const throwInternalError = message => { throw new InternalError(message) }; const whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => { myTypes.forEach(function (type) { typeDependencies[type] = dependentTypes }); function onComplete (typeConverters) { const myTypeConverters = getTypeConverters(typeConverters); if (myTypeConverters.length !== myTypes.length) { throwInternalError('Mismatched type converter count') } for (let i = 0; i < myTypes.length; ++i) { registerType(myTypes[i], myTypeConverters[i]) } } const typeConverters = new Array(dependentTypes.length); const unregisteredTypes = []; let registered = 0; dependentTypes.forEach((dt, i) => { if (registeredTypes.hasOwnProperty(dt)) { typeConverters[i] = registeredTypes[dt] } else { unregisteredTypes.push(dt); if (!awaitingDependencies.hasOwnProperty(dt)) { awaitingDependencies[dt] = [] }awaitingDependencies[dt].push(() => { typeConverters[i] = registeredTypes[dt]; ++registered; if (registered === unregisteredTypes.length) { onComplete(typeConverters) } }) } }); if (unregisteredTypes.length === 0) { onComplete(typeConverters) } }; function sharedRegisterType (rawType, registeredInstance, options = {}) { const name = registeredInstance.name; if (!rawType) { throwBindingError(`type "${name}" must have a positive integer typeid pointer`) } if (registeredTypes.hasOwnProperty(rawType)) { if (options.ignoreDuplicateRegistrations) { return } else { throwBindingError(`Cannot register type '${name}' twice`) } }registeredTypes[rawType] = registeredInstance; delete typeDependencies[rawType]; if (awaitingDependencies.hasOwnProperty(rawType)) { const callbacks = awaitingDependencies[rawType]; delete awaitingDependencies[rawType]; callbacks.forEach(cb => cb()) } } function registerType (rawType, registeredInstance, options = {}) { if (!('argPackAdvance' in registeredInstance)) { throw new TypeError('registerType registeredInstance requires argPackAdvance') } return sharedRegisterType(rawType, registeredInstance, options) } const GenericWireTypeSize = 8; function __embind_register_bool (rawType, name, trueValue, falseValue) { rawType >>>= 0; name >>>= 0; name = readLatin1String(name); registerType(rawType, { name, fromWireType: function (wt) { return !!wt }, toWireType: function (destructors, o) { return o ? trueValue : falseValue }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: function (pointer) { return this.fromWireType(HEAPU8[pointer >>> 0]) }, destructorFunction: null }) } function handleAllocatorInit () { Object.assign(HandleAllocator.prototype, { get (id) { return this.allocated[id] }, has (id) { return this.allocated[id] !== undefined }, allocate (handle) { const id = this.freelist.pop() || this.allocated.length; this.allocated[id] = handle; return id }, free (id) { this.allocated[id] = undefined; this.freelist.push(id) } }) } function HandleAllocator () { this.allocated = [undefined]; this.freelist = [] } const emval_handles = new HandleAllocator(); function __emval_decref (handle) { handle >>>= 0; if (handle >= emval_handles.reserved && --emval_handles.get(handle).refcount === 0) { emval_handles.free(handle) } } const count_emval_handles = () => { let count = 0; for (let i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) { if (emval_handles.allocated[i] !== undefined) { ++count } } return count }; const init_emval = () => { emval_handles.allocated.push({ value: undefined }, { value: null }, { value: true }, { value: false }); emval_handles.reserved = emval_handles.allocated.length; Module.count_emval_handles = count_emval_handles }; const Emval = { toValue: handle => { if (!handle) { throwBindingError('Cannot use deleted val. handle = ' + handle) } return emval_handles.get(handle).value }, toHandle: value => { switch (value) { case undefined:return 1; case null:return 2; case true:return 3; case false:return 4; default:{ return emval_handles.allocate({ refcount: 1, value }) } } } }; function simpleReadValueFromPointer (pointer) { return this.fromWireType(HEAP32[pointer >>> 2 >>> 0]) } const __embind_register_emval = function (rawType, name) { rawType >>>= 0; name >>>= 0; name = readLatin1String(name); registerType(rawType, { name, fromWireType: handle => { const rv = Emval.toValue(handle); __emval_decref(handle); return rv }, toWireType: (destructors, value) => Emval.toHandle(value), argPackAdvance: GenericWireTypeSize, readValueFromPointer: simpleReadValueFromPointer, destructorFunction: null }) }; const floatReadValueFromPointer = (name, width) => { switch (width) { case 4:return function (pointer) { return this.fromWireType(HEAPF32[pointer >>> 2 >>> 0]) }; case 8:return function (pointer) { return this.fromWireType(HEAPF64[pointer >>> 3 >>> 0]) }; default:throw new TypeError(`invalid float width (${width}): ${name}`) } }; const __embind_register_float = function (rawType, name, size) { rawType >>>= 0; name >>>= 0; size >>>= 0; name = readLatin1String(name); registerType(rawType, { name, fromWireType: value => value, toWireType: (destructors, value) => value, argPackAdvance: GenericWireTypeSize, readValueFromPointer: floatReadValueFromPointer(name, size), destructorFunction: null }) }; const createNamedFunction = (name, body) => Object.defineProperty(body, 'name', { value: name }); const runDestructors = destructors => { while (destructors.length) { const ptr = destructors.pop(); const del = destructors.pop(); del(ptr) } }; function usesDestructorStack (argTypes) { for (let i = 1; i < argTypes.length; ++i) { if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { return true } } return false } function newFunc (constructor, argumentList) { if (!(constructor instanceof Function)) { throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`) } const dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function () {}); dummy.prototype = constructor.prototype; const obj = new dummy(); const r = constructor.apply(obj, argumentList); return r instanceof Object ? r : obj } function createJsInvoker (humanName, argTypes, isClassMethodFunc, returns, isAsync) { const needsDestructorStack = usesDestructorStack(argTypes); const argCount = argTypes.length; let argsList = ''; let argsListWired = ''; for (var i = 0; i < argCount - 2; ++i) { argsList += (i !== 0 ? ', ' : '') + 'arg' + i; argsListWired += (i !== 0 ? ', ' : '') + 'arg' + i + 'Wired' } let invokerFnBody = `\n        return function (${argsList}) {\n        if (arguments.length !== ${argCount - 2}) {\n          throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2}');\n        }`; if (needsDestructorStack) { invokerFnBody += 'var destructors = [];\n' } const dtorStack = needsDestructorStack ? 'destructors' : 'null'; const args1 = ['throwBindingError', 'invoker', 'fn', 'runDestructors', 'retType', 'classParam']; if (isClassMethodFunc) { invokerFnBody += "var thisWired = classParam['toWireType'](" + dtorStack + ', this);\n' } for (var i = 0; i < argCount - 2; ++i) { invokerFnBody += 'var arg' + i + 'Wired = argType' + i + "['toWireType'](" + dtorStack + ', arg' + i + '); // ' + argTypes[i + 2].name + '\n'; args1.push('argType' + i) } if (isClassMethodFunc) { argsListWired = 'thisWired' + (argsListWired.length > 0 ? ', ' : '') + argsListWired }invokerFnBody += (returns || isAsync ? 'var rv = ' : '') + 'invoker(fn' + (argsListWired.length > 0 ? ', ' : '') + argsListWired + ');\n'; if (needsDestructorStack) { invokerFnBody += 'runDestructors(destructors);\n' } else { for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) { const paramName = i === 1 ? 'thisWired' : 'arg' + (i - 2) + 'Wired'; if (argTypes[i].destructorFunction !== null) { invokerFnBody += paramName + '_dtor(' + paramName + '); // ' + argTypes[i].name + '\n'; args1.push(paramName + '_dtor') } } } if (returns) { invokerFnBody += "var ret = retType['fromWireType'](rv);\n" + 'return ret;\n' } else {}invokerFnBody += '}\n'; return [args1, invokerFnBody] } function craftInvokerFunction (humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) { const argCount = argTypes.length; if (argCount < 2) { throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!") } const isClassMethodFunc = argTypes[1] !== null && classType !== null; const needsDestructorStack = usesDestructorStack(argTypes); const returns = argTypes[0].name !== 'void'; const closureArgs = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]]; for (var i = 0; i < argCount - 2; ++i) { closureArgs.push(argTypes[i + 2]) } if (!needsDestructorStack) { for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) { if (argTypes[i].destructorFunction !== null) { closureArgs.push(argTypes[i].destructorFunction) } } } const [args, invokerFnBody] = createJsInvoker(humanName, argTypes, isClassMethodFunc, returns, isAsync); args.push(invokerFnBody); const invokerFn = newFunc(Function, args).apply(null, closureArgs); return createNamedFunction(humanName, invokerFn) } const ensureOverloadTable = (proto, methodName, humanName) => { if (undefined === proto[methodName].overloadTable) { const prevFunc = proto[methodName]; proto[methodName] = function () { if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) { throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`) } return proto[methodName].overloadTable[arguments.length].apply(this, arguments) }; proto[methodName].overloadTable = []; proto[methodName].overloadTable[prevFunc.argCount] = prevFunc } }; const exposePublicSymbol = (name, value, numArguments) => { if (Module.hasOwnProperty(name)) { if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) { throwBindingError(`Cannot register public name '${name}' twice`) }ensureOverloadTable(Module, name, name); if (Module.hasOwnProperty(numArguments)) { throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`) }Module[name].overloadTable[numArguments] = value } else { Module[name] = value; if (undefined !== numArguments) { Module[name].numArguments = numArguments } } }; const heap32VectorToArray = (count, firstElement) => { const array = []; for (let i = 0; i < count; i++) { array.push(HEAPU32[firstElement + i * 4 >>> 2 >>> 0]) } return array }; const replacePublicSymbol = (name, value, numArguments) => { if (!Module.hasOwnProperty(name)) { throwInternalError('Replacing nonexistant public symbol') } if (undefined !== Module[name].overloadTable && undefined !== numArguments) { Module[name].overloadTable[numArguments] = value } else { Module[name] = value; Module[name].argCount = numArguments } }; const dynCallLegacy = (sig, ptr, args) => { const f = Module['dynCall_' + sig]; return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr) }; const wasmTableMirror = []; let wasmTable; const getWasmTableEntry = funcPtr => { let func = wasmTableMirror[funcPtr]; if (!func) { if (funcPtr >= wasmTableMirror.length)wasmTableMirror.length = funcPtr + 1; wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr) } return func }; const dynCall = (sig, ptr, args) => { if (sig.includes('j')) { return dynCallLegacy(sig, ptr, args) } const rtn = getWasmTableEntry(ptr).apply(null, args); return rtn }; const getDynCaller = (sig, ptr) => { const argCache = []; return function () { argCache.length = 0; Object.assign(argCache, arguments); return dynCall(sig, ptr, argCache) } }; const embind__requireFunction = (signature, rawFunction) => { signature = readLatin1String(signature); function makeDynCaller () { if (signature.includes('j')) { return getDynCaller(signature, rawFunction) } return getWasmTableEntry(rawFunction) } const fp = makeDynCaller(); if (typeof fp !== 'function') { throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`) } return fp }; const extendError = (baseErrorType, errorName) => { const errorClass = createNamedFunction(errorName, function (message) { this.name = errorName; this.message = message; const stack = new Error(message).stack; if (stack !== undefined) { this.stack = this.toString() + '\n' + stack.replace(/^Error(:[^\n]*)?\n/, '') } }); errorClass.prototype = Object.create(baseErrorType.prototype); errorClass.prototype.constructor = errorClass; errorClass.prototype.toString = function () { if (this.message === undefined) { return this.name } else { return `${this.name}: ${this.message}` } }; return errorClass }; let UnboundTypeError; const getTypeName = type => { const ptr = ___getTypeName(type); const rv = readLatin1String(ptr); _free(ptr); return rv }; const throwUnboundTypeError = (message, types) => { const unboundTypes = []; const seen = {}; function visit (type) { if (seen[type]) { return } if (registeredTypes[type]) { return } if (typeDependencies[type]) { typeDependencies[type].forEach(visit); return }unboundTypes.push(type); seen[type] = true }types.forEach(visit); throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', '])) }; const getFunctionName = signature => { signature = signature.trim(); const argsIndex = signature.indexOf('('); if (argsIndex !== -1) { return signature.substr(0, argsIndex) } else { return signature } }; function __embind_register_function (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) { name >>>= 0; rawArgTypesAddr >>>= 0; signature >>>= 0; rawInvoker >>>= 0; fn >>>= 0; const argTypes = heap32VectorToArray(argCount, rawArgTypesAddr); name = readLatin1String(name); name = getFunctionName(name); rawInvoker = embind__requireFunction(signature, rawInvoker); exposePublicSymbol(name, function () { throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes) }, argCount - 1); whenDependentTypesAreResolved([], argTypes, function (argTypes) { const invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1)); replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1); return [] }) } const integerReadValueFromPointer = (name, width, signed) => { switch (width) { case 1:return signed ? pointer => HEAP8[pointer >>> 0 >>> 0] : pointer => HEAPU8[pointer >>> 0 >>> 0]; case 2:return signed ? pointer => HEAP16[pointer >>> 1 >>> 0] : pointer => HEAPU16[pointer >>> 1 >>> 0]; case 4:return signed ? pointer => HEAP32[pointer >>> 2 >>> 0] : pointer => HEAPU32[pointer >>> 2 >>> 0]; default:throw new TypeError(`invalid integer width (${width}): ${name}`) } }; function __embind_register_integer (primitiveType, name, size, minRange, maxRange) { primitiveType >>>= 0; name >>>= 0; size >>>= 0; name = readLatin1String(name); if (maxRange === -1) { maxRange = 4294967295 } let fromWireType = value => value; if (minRange === 0) { const bitshift = 32 - 8 * size; fromWireType = value => value << bitshift >>> bitshift } const isUnsignedType = name.includes('unsigned'); const checkAssertions = (value, toTypeName) => {}; let toWireType; if (isUnsignedType) { toWireType = function (destructors, value) { checkAssertions(value, this.name); return value >>> 0 } } else { toWireType = function (destructors, value) { checkAssertions(value, this.name); return value } }registerType(primitiveType, { name, fromWireType, toWireType, argPackAdvance: GenericWireTypeSize, readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0), destructorFunction: null }) } function __embind_register_memory_view (rawType, dataTypeIndex, name) { rawType >>>= 0; name >>>= 0; const typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array]; const TA = typeMapping[dataTypeIndex]; function decodeMemoryView (handle) { const size = HEAPU32[handle >>> 2 >>> 0]; const data = HEAPU32[handle + 4 >>> 2 >>> 0]; return new TA(HEAP8.buffer, data, size) }name = readLatin1String(name); registerType(rawType, { name, fromWireType: decodeMemoryView, argPackAdvance: GenericWireTypeSize, readValueFromPointer: decodeMemoryView }, { ignoreDuplicateRegistrations: true }) } function readPointer (pointer) { return this.fromWireType(HEAPU32[pointer >>> 2 >>> 0]) } const stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => { outIdx >>>= 0; if (!(maxBytesToWrite > 0)) return 0; const startIdx = outIdx; const endIdx = outIdx + maxBytesToWrite - 1; for (let i = 0; i < str.length; ++i) { let u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) { const u1 = str.charCodeAt(++i); u = 65536 + ((u & 1023) << 10) | u1 & 1023 } if (u <= 127) { if (outIdx >= endIdx) break; heap[outIdx++ >>> 0] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; heap[outIdx++ >>> 0] = 192 | u >> 6; heap[outIdx++ >>> 0] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; heap[outIdx++ >>> 0] = 224 | u >> 12; heap[outIdx++ >>> 0] = 128 | u >> 6 & 63; heap[outIdx++ >>> 0] = 128 | u & 63 } else { if (outIdx + 3 >= endIdx) break; heap[outIdx++ >>> 0] = 240 | u >> 18; heap[outIdx++ >>> 0] = 128 | u >> 12 & 63; heap[outIdx++ >>> 0] = 128 | u >> 6 & 63; heap[outIdx++ >>> 0] = 128 | u & 63 } }heap[outIdx >>> 0] = 0; return outIdx - startIdx }; const stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite); const lengthBytesUTF8 = str => { let len = 0; for (let i = 0; i < str.length; ++i) { const c = str.charCodeAt(i); if (c <= 127) { len++ } else if (c <= 2047) { len += 2 } else if (c >= 55296 && c <= 57343) { len += 4; ++i } else { len += 3 } } return len }; const UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined; const UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => { idx >>>= 0; const endIdx = idx + maxBytesToRead; let endPtr = idx; while (heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr; if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) { return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr)) } let str = ''; while (idx < endPtr) { let u0 = heapOrArray[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } const u1 = heapOrArray[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } const u2 = heapOrArray[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { const ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } return str }; const UTF8ToString = (ptr, maxBytesToRead) => { ptr >>>= 0; return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '' }; function __embind_register_std_string (rawType, name) { rawType >>>= 0; name >>>= 0; name = readLatin1String(name); const stdStringIsUTF8 = name === 'std::string'; registerType(rawType, { name, 'fromWireType' (value) { const length = HEAPU32[value >>> 2 >>> 0]; const payload = value + 4; let str; if (stdStringIsUTF8) { let decodeStartPtr = payload; for (var i = 0; i <= length; ++i) { const currentBytePtr = payload + i; if (i == length || HEAPU8[currentBytePtr >>> 0] == 0) { const maxRead = currentBytePtr - decodeStartPtr; const stringSegment = UTF8ToString(decodeStartPtr, maxRead); if (str === undefined) { str = stringSegment } else { str += String.fromCharCode(0); str += stringSegment }decodeStartPtr = currentBytePtr + 1 } } } else { const a = new Array(length); for (var i = 0; i < length; ++i) { a[i] = String.fromCharCode(HEAPU8[payload + i >>> 0]) }str = a.join('') }_free(value); return str }, 'toWireType' (destructors, value) { if (value instanceof ArrayBuffer) { value = new Uint8Array(value) } let length; const valueIsOfTypeString = typeof value === 'string'; if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) { throwBindingError('Cannot pass non-string to std::string') } if (stdStringIsUTF8 && valueIsOfTypeString) { length = lengthBytesUTF8(value) } else { length = value.length } const base = _malloc(4 + length + 1); const ptr = base + 4; HEAPU32[base >>> 2 >>> 0] = length; if (stdStringIsUTF8 && valueIsOfTypeString) { stringToUTF8(value, ptr, length + 1) } else { if (valueIsOfTypeString) { for (var i = 0; i < length; ++i) { const charCode = value.charCodeAt(i); if (charCode > 255) { _free(ptr); throwBindingError('String has UTF-16 code units that do not fit in 8 bits') }HEAPU8[ptr + i >>> 0] = charCode } } else { for (var i = 0; i < length; ++i) { HEAPU8[ptr + i >>> 0] = value[i] } } } if (destructors !== null) { destructors.push(_free, base) } return base }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction (ptr) { _free(ptr) } }) } const UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined; const UTF16ToString = (ptr, maxBytesToRead) => { let endPtr = ptr; let idx = endPtr >> 1; const maxIdx = idx + maxBytesToRead / 2; while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])++idx; endPtr = idx << 1; if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0)); let str = ''; for (let i = 0; !(i >= maxBytesToRead / 2); ++i) { const codeUnit = HEAP16[ptr + i * 2 >>> 1 >>> 0]; if (codeUnit == 0) break; str += String.fromCharCode(codeUnit) } return str }; const stringToUTF16 = (str, outPtr, maxBytesToWrite) => { maxBytesToWrite ??= 2147483647; if (maxBytesToWrite < 2) return 0; maxBytesToWrite -= 2; const startPtr = outPtr; const numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length; for (let i = 0; i < numCharsToWrite; ++i) { const codeUnit = str.charCodeAt(i); HEAP16[outPtr >>> 1 >>> 0] = codeUnit; outPtr += 2 }HEAP16[outPtr >>> 1 >>> 0] = 0; return outPtr - startPtr }; const lengthBytesUTF16 = str => str.length * 2; const UTF32ToString = (ptr, maxBytesToRead) => { let i = 0; let str = ''; while (!(i >= maxBytesToRead / 4)) { const utf32 = HEAP32[ptr + i * 4 >>> 2 >>> 0]; if (utf32 == 0) break; ++i; if (utf32 >= 65536) { const ch = utf32 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } else { str += String.fromCharCode(utf32) } } return str }; const stringToUTF32 = (str, outPtr, maxBytesToWrite) => { outPtr >>>= 0; maxBytesToWrite ??= 2147483647; if (maxBytesToWrite < 4) return 0; const startPtr = outPtr; const endPtr = startPtr + maxBytesToWrite - 4; for (let i = 0; i < str.length; ++i) { let codeUnit = str.charCodeAt(i); if (codeUnit >= 55296 && codeUnit <= 57343) { const trailSurrogate = str.charCodeAt(++i); codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023 }HEAP32[outPtr >>> 2 >>> 0] = codeUnit; outPtr += 4; if (outPtr + 4 > endPtr) break }HEAP32[outPtr >>> 2 >>> 0] = 0; return outPtr - startPtr }; const lengthBytesUTF32 = str => { let len = 0; for (let i = 0; i < str.length; ++i) { const codeUnit = str.charCodeAt(i); if (codeUnit >= 55296 && codeUnit <= 57343)++i; len += 4 } return len }; const __embind_register_std_wstring = function (rawType, charSize, name) { rawType >>>= 0; charSize >>>= 0; name >>>= 0; name = readLatin1String(name); let decodeString, encodeString, getHeap, lengthBytesUTF, shift; if (charSize === 2) { decodeString = UTF16ToString; encodeString = stringToUTF16; lengthBytesUTF = lengthBytesUTF16; getHeap = () => HEAPU16; shift = 1 } else if (charSize === 4) { decodeString = UTF32ToString; encodeString = stringToUTF32; lengthBytesUTF = lengthBytesUTF32; getHeap = () => HEAPU32; shift = 2 }registerType(rawType, { name, fromWireType: value => { const length = HEAPU32[value >>> 2 >>> 0]; const HEAP = getHeap(); let str; let decodeStartPtr = value + 4; for (let i = 0; i <= length; ++i) { const currentBytePtr = value + 4 + i * charSize; if (i == length || HEAP[currentBytePtr >>> shift] == 0) { const maxReadBytes = currentBytePtr - decodeStartPtr; const stringSegment = decodeString(decodeStartPtr, maxReadBytes); if (str === undefined) { str = stringSegment } else { str += String.fromCharCode(0); str += stringSegment }decodeStartPtr = currentBytePtr + charSize } }_free(value); return str }, toWireType: (destructors, value) => { if (!(typeof value === 'string')) { throwBindingError(`Cannot pass non-string to C++ string type ${name}`) } const length = lengthBytesUTF(value); const ptr = _malloc(4 + length + charSize); HEAPU32[ptr >>> 2] = length >> shift; encodeString(value, ptr + 4, length + charSize); if (destructors !== null) { destructors.push(_free, ptr) } return ptr }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: simpleReadValueFromPointer, destructorFunction (ptr) { _free(ptr) } }) }; const __embind_register_void = function (rawType, name) { rawType >>>= 0; name >>>= 0; name = readLatin1String(name); registerType(rawType, { isVoid: true, name, argPackAdvance: 0, fromWireType: () => undefined, toWireType: (destructors, o) => undefined }) }; const nowIsMonotonic = 1; const __emscripten_get_now_is_monotonic = () => nowIsMonotonic; const _abort = () => { abort('') }; const _emscripten_date_now = () => Date.now(); let _emscripten_get_now; _emscripten_get_now = () => performance.now(); function _emscripten_memcpy_js (dest, src, num) { dest >>>= 0; src >>>= 0; num >>>= 0; return HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0) } const abortOnCannotGrowMemory = requestedSize => { abort('OOM') }; function _emscripten_resize_heap (requestedSize) { requestedSize >>>= 0; const oldSize = HEAPU8.length; abortOnCannotGrowMemory(requestedSize) } const ENV = {}; const getExecutableName = () => thisProgram || './this.program'; const getEnvStrings = () => { if (!getEnvStrings.strings) { const lang = (typeof navigator === 'object' && navigator.languages && navigator.languages[0] || 'C').replace('-', '_') + '.UTF-8'; const env = { USER: 'web_user', LOGNAME: 'web_user', PATH: '/', PWD: '/', HOME: '/home/web_user', LANG: lang, _: getExecutableName() }; for (var x in ENV) { if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x] } const strings = []; for (var x in env) { strings.push(`${x}=${env[x]}`) }getEnvStrings.strings = strings } return getEnvStrings.strings }; const stringToAscii = (str, buffer) => { for (let i = 0; i < str.length; ++i) { HEAP8[buffer++ >>> 0 >>> 0] = str.charCodeAt(i) }HEAP8[buffer >>> 0 >>> 0] = 0 }; var SYSCALLS = { varargs: undefined, get () { const ret = HEAP32[+SYSCALLS.varargs >>> 2 >>> 0]; SYSCALLS.varargs += 4; return ret }, getp () { return SYSCALLS.get() }, getStr (ptr) { const ret = UTF8ToString(ptr); return ret } }; const _environ_get = function (__environ, environ_buf) { __environ >>>= 0; environ_buf >>>= 0; let bufSize = 0; getEnvStrings().forEach((string, i) => { const ptr = environ_buf + bufSize; HEAPU32[__environ + i * 4 >>> 2 >>> 0] = ptr; stringToAscii(string, ptr); bufSize += string.length + 1 }); return 0 }; const _environ_sizes_get = function (penviron_count, penviron_buf_size) { penviron_count >>>= 0; penviron_buf_size >>>= 0; const strings = getEnvStrings(); HEAPU32[penviron_count >>> 2 >>> 0] = strings.length; let bufSize = 0; strings.forEach(string => bufSize += string.length + 1); HEAPU32[penviron_buf_size >>> 2 >>> 0] = bufSize; return 0 }; const initRandomFill = () => { if (typeof crypto === 'object' && typeof crypto.getRandomValues === 'function') { return view => crypto.getRandomValues(view) } else abort('initRandomDevice') }; let randomFill = view => (randomFill = initRandomFill())(view); function _getentropy (buffer, size) { buffer >>>= 0; size >>>= 0; randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0)); return 0 } const isLeapYear = year => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0); const arraySum = (array, index) => { let sum = 0; for (let i = 0; i <= index; sum += array[i++]) {} return sum }; const MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; const MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; const addDays = (date, days) => { const newDate = new Date(date.getTime()); while (days > 0) { const leap = isLeapYear(newDate.getFullYear()); const currentMonth = newDate.getMonth(); const daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth]; if (days > daysInCurrentMonth - newDate.getDate()) { days -= daysInCurrentMonth - newDate.getDate() + 1; newDate.setDate(1); if (currentMonth < 11) { newDate.setMonth(currentMonth + 1) } else { newDate.setMonth(0); newDate.setFullYear(newDate.getFullYear() + 1) } } else { newDate.setDate(newDate.getDate() + days); return newDate } } return newDate }; function intArrayFromString (stringy, dontAddNull, length) { const len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; const u8array = new Array(len); const numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull)u8array.length = numBytesWritten; return u8array } const writeArrayToMemory = (array, buffer) => { HEAP8.set(array, buffer >>> 0) }; function _strftime (s, maxsize, format, tm) { s >>>= 0; maxsize >>>= 0; format >>>= 0; tm >>>= 0; const tm_zone = HEAPU32[tm + 40 >>> 2 >>> 0]; const date = { tm_sec: HEAP32[tm >>> 2 >>> 0], tm_min: HEAP32[tm + 4 >>> 2 >>> 0], tm_hour: HEAP32[tm + 8 >>> 2 >>> 0], tm_mday: HEAP32[tm + 12 >>> 2 >>> 0], tm_mon: HEAP32[tm + 16 >>> 2 >>> 0], tm_year: HEAP32[tm + 20 >>> 2 >>> 0], tm_wday: HEAP32[tm + 24 >>> 2 >>> 0], tm_yday: HEAP32[tm + 28 >>> 2 >>> 0], tm_isdst: HEAP32[tm + 32 >>> 2 >>> 0], tm_gmtoff: HEAP32[tm + 36 >>> 2 >>> 0], tm_zone: tm_zone ? UTF8ToString(tm_zone) : '' }; let pattern = UTF8ToString(format); const EXPANSION_RULES_1 = { '%c': '%a %b %d %H:%M:%S %Y', '%D': '%m/%d/%y', '%F': '%Y-%m-%d', '%h': '%b', '%r': '%I:%M:%S %p', '%R': '%H:%M', '%T': '%H:%M:%S', '%x': '%m/%d/%y', '%X': '%H:%M:%S', '%Ec': '%c', '%EC': '%C', '%Ex': '%m/%d/%y', '%EX': '%H:%M:%S', '%Ey': '%y', '%EY': '%Y', '%Od': '%d', '%Oe': '%e', '%OH': '%H', '%OI': '%I', '%Om': '%m', '%OM': '%M', '%OS': '%S', '%Ou': '%u', '%OU': '%U', '%OV': '%V', '%Ow': '%w', '%OW': '%W', '%Oy': '%y' }; for (var rule in EXPANSION_RULES_1) { pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]) } const WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; const MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']; function leadingSomething (value, digits, character) { let str = typeof value === 'number' ? value.toString() : value || ''; while (str.length < digits) { str = character[0] + str } return str } function leadingNulls (value, digits) { return leadingSomething(value, digits, '0') } function compareByDay (date1, date2) { function sgn (value) { return value < 0 ? -1 : value > 0 ? 1 : 0 } let compare; if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) { if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) { compare = sgn(date1.getDate() - date2.getDate()) } } return compare } function getFirstWeekStartDate (janFourth) { switch (janFourth.getDay()) { case 0:return new Date(janFourth.getFullYear() - 1, 11, 29); case 1:return janFourth; case 2:return new Date(janFourth.getFullYear(), 0, 3); case 3:return new Date(janFourth.getFullYear(), 0, 2); case 4:return new Date(janFourth.getFullYear(), 0, 1); case 5:return new Date(janFourth.getFullYear() - 1, 11, 31); case 6:return new Date(janFourth.getFullYear() - 1, 11, 30) } } function getWeekBasedYear (date) { const thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); const janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4); const janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4); const firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear); const firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) { if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) { return thisDate.getFullYear() + 1 } return thisDate.getFullYear() } return thisDate.getFullYear() - 1 } const EXPANSION_RULES_2 = { '%a': date => WEEKDAYS[date.tm_wday].substring(0, 3), '%A': date => WEEKDAYS[date.tm_wday], '%b': date => MONTHS[date.tm_mon].substring(0, 3), '%B': date => MONTHS[date.tm_mon], '%C': date => { const year = date.tm_year + 1900; return leadingNulls(year / 100 | 0, 2) }, '%d': date => leadingNulls(date.tm_mday, 2), '%e': date => leadingSomething(date.tm_mday, 2, ' '), '%g': date => getWeekBasedYear(date).toString().substring(2), '%G': date => getWeekBasedYear(date), '%H': date => leadingNulls(date.tm_hour, 2), '%I': date => { let twelveHour = date.tm_hour; if (twelveHour == 0)twelveHour = 12; else if (twelveHour > 12)twelveHour -= 12; return leadingNulls(twelveHour, 2) }, '%j': date => leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3), '%m': date => leadingNulls(date.tm_mon + 1, 2), '%M': date => leadingNulls(date.tm_min, 2), '%n': () => '\n', '%p': date => { if (date.tm_hour >= 0 && date.tm_hour < 12) { return 'AM' } return 'PM' }, '%S': date => leadingNulls(date.tm_sec, 2), '%t': () => '\t', '%u': date => date.tm_wday || 7, '%U': date => { const days = date.tm_yday + 7 - date.tm_wday; return leadingNulls(Math.floor(days / 7), 2) }, '%V': date => { let val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7); if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) { val++ } if (!val) { val = 52; const dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7; if (dec31 == 4 || dec31 == 5 && isLeapYear(date.tm_year % 400 - 1)) { val++ } } else if (val == 53) { const jan1 = (date.tm_wday + 371 - date.tm_yday) % 7; if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year)))val = 1 } return leadingNulls(val, 2) }, '%w': date => date.tm_wday, '%W': date => { const days = date.tm_yday + 7 - (date.tm_wday + 6) % 7; return leadingNulls(Math.floor(days / 7), 2) }, '%y': date => (date.tm_year + 1900).toString().substring(2), '%Y': date => date.tm_year + 1900, '%z': date => { let off = date.tm_gmtoff; const ahead = off >= 0; off = Math.abs(off) / 60; off = off / 60 * 100 + off % 60; return (ahead ? '+' : '-') + String('0000' + off).slice(-4) }, '%Z': date => date.tm_zone, '%%': () => '%' }; pattern = pattern.replace(/%%/g, '\0\0'); for (var rule in EXPANSION_RULES_2) { if (pattern.includes(rule)) { pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date)) } }pattern = pattern.replace(/\0\0/g, '%'); const bytes = intArrayFromString(pattern, false); if (bytes.length > maxsize) { return 0 }writeArrayToMemory(bytes, s); return bytes.length - 1 } function _strftime_l (s, maxsize, format, tm, loc) { s >>>= 0; maxsize >>>= 0; format >>>= 0; tm >>>= 0; loc >>>= 0; return _strftime(s, maxsize, format, tm) }embind_init_charCodes(); BindingError = Module.BindingError = class BindingError extends Error {constructor (message) { super(message); this.name = 'BindingError' }}; InternalError = Module.InternalError = class InternalError extends Error {constructor (message) { super(message); this.name = 'InternalError' }}; handleAllocatorInit(); init_emval(); UnboundTypeError = Module.UnboundTypeError = extendError(Error, 'UnboundTypeError'); var wasmImports = { t: ___cxa_begin_catch, z: ___cxa_end_catch, b: ___cxa_find_matching_catch_2, g: ___cxa_find_matching_catch_3, G: ___cxa_rethrow, a: ___cxa_throw, O: ___cxa_uncaught_exceptions, e: ___resumeException, L: __embind_register_bigint, P: __embind_register_bool, I: __embind_register_emval, B: __embind_register_float, q: __embind_register_function, o: __embind_register_integer, k: __embind_register_memory_view, A: __embind_register_std_string, w: __embind_register_std_wstring, Q: __embind_register_void, U: __emscripten_get_now_is_monotonic, x: _abort, H: _emscripten_date_now, V: _emscripten_memcpy_js, R: _emscripten_resize_heap, S: _environ_get, T: _environ_sizes_get, M: _getentropy, C: invoke_diii, y: invoke_fiii, j: invoke_i, c: invoke_ii, f: invoke_iii, m: invoke_iiii, h: invoke_iiiii, E: invoke_iiiiii, p: invoke_iiiiiii, D: invoke_iiiiiiii, v: invoke_iiiiiiiiiiii, K: invoke_j, J: invoke_jiiii, i: invoke_v, r: invoke_vi, d: invoke_vii, l: invoke_viii, F: invoke_viiii, n: invoke_viiiiiii, s: invoke_viiiiiiiiii, u: invoke_viiiiiiiiiiiiiii, N: _strftime_l }; var wasmExports = createWasm(); let ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports.X)(); var _free = a0 => (_free = wasmExports.Z)(a0); var ___getTypeName = a0 => (___getTypeName = wasmExports._)(a0); let ___errno_location = () => (___errno_location = wasmExports.__errno_location)(); var _malloc = a0 => (_malloc = wasmExports.$)(a0); var _setThrew = (a0, a1) => (_setThrew = wasmExports.aa)(a0, a1); var setTempRet0 = a0 => (setTempRet0 = wasmExports.ba)(a0); let stackSave = () => (stackSave = wasmExports.ca)(); let stackRestore = a0 => (stackRestore = wasmExports.da)(a0); let ___cxa_free_exception = a0 => (___cxa_free_exception = wasmExports.__cxa_free_exception)(a0); var ___cxa_decrement_exception_refcount = a0 => (___cxa_decrement_exception_refcount = wasmExports.ea)(a0); var ___cxa_increment_exception_refcount = a0 => (___cxa_increment_exception_refcount = wasmExports.fa)(a0); var ___cxa_can_catch = (a0, a1, a2) => (___cxa_can_catch = wasmExports.ga)(a0, a1, a2); var ___cxa_is_pointer_type = a0 => (___cxa_is_pointer_type = wasmExports.ha)(a0); var dynCall_ji = Module.dynCall_ji = (a0, a1) => (dynCall_ji = Module.dynCall_ji = wasmExports.ia)(a0, a1); var dynCall_vij = Module.dynCall_vij = (a0, a1, a2, a3) => (dynCall_vij = Module.dynCall_vij = wasmExports.ja)(a0, a1, a2, a3); var dynCall_iifffj = Module.dynCall_iifffj = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iifffj = Module.dynCall_iifffj = wasmExports.ka)(a0, a1, a2, a3, a4, a5, a6); var dynCall_j = Module.dynCall_j = a0 => (dynCall_j = Module.dynCall_j = wasmExports.la)(a0); var dynCall_viijii = Module.dynCall_viijii = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_viijii = Module.dynCall_viijii = wasmExports.ma)(a0, a1, a2, a3, a4, a5, a6); var dynCall_jiiii = Module.dynCall_jiiii = (a0, a1, a2, a3, a4) => (dynCall_jiiii = Module.dynCall_jiiii = wasmExports.na)(a0, a1, a2, a3, a4); var dynCall_iiiiij = Module.dynCall_iiiiij = (a0, a1, a2, a3, a4, a5, a6) => (dynCall_iiiiij = Module.dynCall_iiiiij = wasmExports.oa)(a0, a1, a2, a3, a4, a5, a6); var dynCall_iiiiijj = Module.dynCall_iiiiijj = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (dynCall_iiiiijj = Module.dynCall_iiiiijj = wasmExports.pa)(a0, a1, a2, a3, a4, a5, a6, a7, a8); var dynCall_iiiiiijj = Module.dynCall_iiiiiijj = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (dynCall_iiiiiijj = Module.dynCall_iiiiiijj = wasmExports.qa)(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); function invoke_iiii (index, a1, a2, a3) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_iii (index, a1, a2) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_ii (index, a1) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_vii (index, a1, a2) { const sp = stackSave(); try { getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_vi (index, a1) { const sp = stackSave(); try { getWasmTableEntry(index)(a1) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_v (index) { const sp = stackSave(); try { getWasmTableEntry(index)() } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_iiiiiii (index, a1, a2, a3, a4, a5, a6) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_viiii (index, a1, a2, a3, a4) { const sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_iiiiii (index, a1, a2, a3, a4, a5) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_viii (index, a1, a2, a3) { const sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_iiiiiiii (index, a1, a2, a3, a4, a5, a6, a7) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_iiiii (index, a1, a2, a3, a4) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_fiii (index, a1, a2, a3) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_diii (index, a1, a2, a3) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_i (index) { const sp = stackSave(); try { return getWasmTableEntry(index)() } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_viiiiiii (index, a1, a2, a3, a4, a5, a6, a7) { const sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_iiiiiiiiiiii (index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiiii (index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) { const sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiiiiiiiii (index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) { const sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_j (index) { const sp = stackSave(); try { return dynCall_j(index) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function invoke_jiiii (index, a1, a2, a3, a4) { const sp = stackSave(); try { return dynCall_jiiii(index, a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (e !== e + 0) throw e; _setThrew(1, 0) } } function applySignatureConversions (wasmExports) { wasmExports = Object.assign({}, wasmExports); const makeWrapper_pp = f => a0 => f(a0) >>> 0; const makeWrapper_p = f => () => f() >>> 0; wasmExports._ = makeWrapper_pp(wasmExports._); wasmExports.__errno_location = makeWrapper_p(wasmExports.__errno_location); wasmExports.$ = makeWrapper_pp(wasmExports.$); wasmExports.ca = makeWrapper_p(wasmExports.ca); wasmExports.stackAlloc = makeWrapper_pp(wasmExports.stackAlloc); return wasmExports } let calledRun; dependenciesFulfilled = function runCaller () { if (!calledRun)run(); if (!calledRun)dependenciesFulfilled = runCaller }; function run () { if (runDependencies > 0) { return }preRun(); if (runDependencies > 0) { return } function doRun () { if (calledRun) return; calledRun = true; Module.calledRun = true; if (ABORT) return; initRuntime(); readyPromiseResolve(Module); if (Module.onRuntimeInitialized)Module.onRuntimeInitialized(); postRun() } if (Module.setStatus) { Module.setStatus('Running...'); setTimeout(function () { setTimeout(function () { Module.setStatus('') }, 1); doRun() }, 1) } else { doRun() } } if (Module.preInit) { if (typeof Module.preInit === 'function')Module.preInit = [Module.preInit]; while (Module.preInit.length > 0) { Module.preInit.pop()() } }run()

      return moduleArg.ready
    }
  )
})()

if (typeof exports === 'object' && typeof module === 'object') { module.exports = Qrack } else if (typeof define === 'function' && define.amd) { define([], () => Qrack) }
